# ------------------------------
# Simulation Parameters
# ------------------------------
p <- 0.99
u <- qnorm(p)
N <- 500  # Number of simulations
# Initialize storage for simulation results
var_matrix <- matrix(nrow = 0, ncol = N)
epys_matrix <- matrix(nrow = 0, ncol = N)
uers <- numeric(N)
lers <- numeric(N)
areas <- numeric(N)
perims <- numeric(N)
# ------------------------------
# Load or Perform Simulations
# ------------------------------
if (file.exists(statistics_path)) {
message("Loading simulation data: ", statistics_path)
load(statistics_path)  # Loads 'lers', 'uers', 'epys', 'var_matrix', 'perims', 'areas'
# Generate a random field for delta calculation
rf_sample <- generateGaussian(gen, u, exceedance = TRUE)
ep_sample <- extent.profile(rf_sample, u, x0 = cond_site)
} else {
message("Starting simulations...")
for (simulation in 1:N) {
if (simulation %% 50 == 0) {
message("Simulation ", simulation, " of ", N)
}
# Generate Gaussian random field exceeding threshold 'u'
rf <- generateGaussian(gen, u, exceedance = TRUE)
# Store field values
var_matrix <- cbind(var_matrix, rf$values)
# Compute extent profile
ep <- extent.profile(rf, u, x0 = cond_site)
epys_matrix <- cbind(epys_matrix, ep$y)
# Compute upper extremal range
uers[simulation] <- upperExtremalRange(rf, u, x0 = cond_site, finite = TRUE)
# Compute lower extremal range
lers[simulation] <- proportion_range(ep, proportion = 1)
# Compute excursion area and perimeter
areas[simulation] <- excursionArea(rf, u)
perims[simulation] <- excursionPerimeter(rf, u)
}
# Save simulation results
save(lers, uers, epys_matrix, var_matrix, perims, areas, file = statistics_path)
message("Simulations completed and saved to ", statistics_path)
}
# ------------------------------
# Bootstrapping Procedure
# ------------------------------
if (file.exists(bootstraps_path)) {
message("Loading bootstrap data: ", bootstraps_path)
load(bootstraps_path)  # Loads 'N_bootstraps', 'df', 'bottom'
} else {
message("Starting bootstrapping...")
# Extract delta from random field sample
delta <- rf_sample$deltas[1]
N_bootstraps <- 200
bootstrap_results <- data.frame(
theta_1 = numeric(N_bootstraps),
theta_2 = numeric(N_bootstraps),
theta_3 = numeric(N_bootstraps),
theta_4 = numeric(N_bootstraps),
theta_5 = numeric(N_bootstraps)
)
for (bs in 1:N_bootstraps) {
if (bs %% 20 == 0) {
message("Bootstrap ", bs, " of ", N_bootstraps)
}
# Sample indices with replacement
bs_indices <- sample(1:N, size = N, replace = TRUE)
# Compute bootstrap estimates
bootstrap_results$theta_1[bs] <- median(lers[bs_indices])
bootstrap_results$theta_2[bs] <- median(uers[bs_indices])
# Update extent profile and compute theta_3
ep_boot <- list(
x = ep_sample$x,
y = apply(epys_matrix[, bs_indices, drop = FALSE], 1, mean)
)
bootstrap_results$theta_3[bs] <- proportion_range(ep_boot, proportion = 0.5)
# Compute excursions and confidence set for theta_4
excursions_result <- excursions::excursions.mc(
var_matrix[, bs_indices],
u = u,
alpha = 0.5,
type = ">"
)
confidence_set <- random.field(excursions_result$F, gen$grid)
bootstrap_results$theta_4[bs] <- sqrt(excursionArea(confidence_set, 0.5))
# Compute theta_5
bootstrap_results$theta_5[bs] <- (8 / pi) * sum(areas[bs_indices]) / sum(perims[bs_indices])
}
# Assign column names
names(bootstrap_results) <- c("theta_1", "theta_2", "theta_3", "theta_4", "theta_5")
# Calculate log(delta) for plotting purposes
bottom <- log(delta)
# Save bootstrap results
save(N_bootstraps, bootstrap_results, bottom, file = bootstraps_path)
message("Bootstrapping completed and saved to ", bootstraps_path)
}
# ------------------------------
# Data Visualization
# ------------------------------
message("Generating boxplots...")
# Generate a sample random field for extent profile
rf_plot <- generateGaussian(gen, 1, exceedance = TRUE)
ep_plot <- extent.profile(rf_plot, 1, x0 = c(x_val, 0))
# Calculate scaling factor
delta_scaled <- exp(bottom)
# Adjust bootstrap results
bootstrap_scaled <- bootstrap_results / delta_scaled
# Define labels for theta parameters
theta_labels <- c(
expression(theta[1]),
expression(theta[2]),
expression(theta[3]),
expression(theta[4]),
expression(theta[5])
)
# Reshape data for ggplot2
df_long <- melt(log2(bootstrap_scaled), variable.name = "Statistic", value.name = "Value")
# Define break lines for the y-axis
break_lines <- seq(0, 7, by = 1)
# Create the boxplot
boxplot_figure <- ggplot(df_long, aes(x = Statistic, y = Value)) +
geom_hline(yintercept = log2(ep_plot$x / delta_scaled)[-1],
color = "lightgrey", linetype = "solid", alpha = 0.5) +  # Horizontal lines based on extent profile
geom_hline(yintercept = break_lines,
color = "darkgrey", linetype = "dashed", alpha = 1) +       # Reference horizontal lines
geom_boxplot(fill = "skyblue", color = "darkblue") +                # Boxplots for each theta
theme_minimal() +
scale_y_continuous(
limits = c(1.5, 7),
breaks = break_lines,
labels = 2^break_lines
) +
labs(x = "", y = "", title = "Bootstrap Distributions of Theta Statistics") +
scale_x_discrete(labels = theta_labels) +
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.text.x = element_text(size = 12),
axis.text.y = element_text(size = 12)
)
# Display the plot
print(boxplot_figure)
# Set working directory (modify as needed)
setwd("C:/Users/rcotsaki/Code/pony-helping-treat/")
# Load necessary libraries
if (!requireNamespace("ExcursionSets", quietly = TRUE)) {
message(paste("Looking in", getwd(), "for ExcursionSets_0.0.4.tar.gz."))
install.packages("ExcursionSets_0.0.4.tar.gz", repos = NULL, type = "source")
}
library(ExcursionSets)
if (!requireNamespace("ggplot2", quietly = TRUE)) {
install.packages("ggplot2")
}
library(ggplot2)
if (!requireNamespace("reshape2", quietly = TRUE)) {
install.packages("reshape2")
}
library(reshape2)
if (!requireNamespace("excursions", quietly = TRUE)) {
install.packages("excursions")
}
library(excursions)
# ------------------------------
# Configuration Parameters
# ------------------------------
HALF_WIDTH <- 0.5  # Set to 2 or 0.5 based on desired configuration
SIDE <- TRUE       # TRUE to choose point on boundary, FALSE otherwise
# Generate file name components based on parameters
fname1 <- if (HALF_WIDTH == 2) "2" else "05"
fname2 <- if (SIDE) "_side" else ""
x_val <- if (SIDE) HALF_WIDTH else 0
# Set working directory (modify as needed)
setwd("C:/Users/rcotsaki/Code/pony-helping-treat/")
# Construct paths for generator and data files
generator_path <- paste0("gaussian_generator_matern_-", fname1, "to", fname1, fname2, ".RData")
# Construct paths for generator and data files
generator_path <- paste0("gaussian_generator_matern_-", fname1, "to", fname1, fname2, ".RData")
statistics_path <- paste0("statistics_-", fname1, "to", fname1, "_u99", fname2, ".RData")
bootstraps_path <- paste0("bootstraps_-", fname1, "to", fname1, "_u99", fname2, ".RData")
# Define conditional site based on SIDE parameter
cond_site <- data.frame(x = x_val, y = 0)
# ------------------------------
# Random Field Generator Setup
# ------------------------------
if (file.exists(generator_path)) {
message("Loading generator: ", generator_path)
load(generator_path)  # Loads 'gen' object
} else {
# Define grid for random field
grid_seq <- seq(-HALF_WIDTH, HALF_WIDTH, length.out = 50)
grid <- expand.grid(x = grid_seq, y = grid_seq)
message("Building the random field generator: ", generator_path,
" from ", min(grid$x), " to ", max(grid$x),
" with ", length(grid_seq), " entries per side.")
# Initialize random field generator with Matern covariance
gen <- random.field.generator(
grid,
cov.model("Matern", nu = 2.5),
cond_sites = cond_site
)
message("Generator built. Saving to ", generator_path, "...")
save(gen, file = generator_path)
message("Generator saved.")
}
# ------------------------------
# Helper Function: Proportion Range
# ------------------------------
proportion_range <- function(ep, proportion = 1) {
# Binary search to find the smallest x such that ep$y[x] < proportion
left <- 1
right <- length(ep$y)
result <- NULL
while (left <= right) {
mid <- floor((left + right) / 2)
if (ep$y[mid] < proportion) {
result <- mid
right <- mid - 1  # Continue searching to the left
} else {
left <- mid + 1    # Continue searching to the right
}
}
if (is.null(result)) {
return(Inf)
}
return(ep$x[result])
}
# ------------------------------
# Simulation Parameters
# ------------------------------
p <- 0.99
u <- qnorm(p)
N <- 500  # Number of simulations
# Initialize storage for simulation results
var_matrix <- matrix(nrow = 0, ncol = N)
epys_matrix <- matrix(nrow = 0, ncol = N)
uers <- numeric(N)
lers <- numeric(N)
areas <- numeric(N)
perims <- numeric(N)
# ------------------------------
# Load or Perform Simulations
# ------------------------------
if (file.exists(statistics_path)) {
message("Loading simulation data: ", statistics_path)
load(statistics_path)  # Loads 'lers', 'uers', 'epys', 'var_matrix', 'perims', 'areas'
# Generate a random field for delta calculation
rf_sample <- generateGaussian(gen, u, exceedance = TRUE)
ep_sample <- extent.profile(rf_sample, u, x0 = cond_site)
} else {
message("Starting simulations...")
for (simulation in 1:N) {
if (simulation %% 50 == 0) {
message("Simulation ", simulation, " of ", N)
}
# Generate Gaussian random field exceeding threshold 'u'
rf <- generateGaussian(gen, u, exceedance = TRUE)
# Store field values
var_matrix <- cbind(var_matrix, rf$values)
# Compute extent profile
ep <- extent.profile(rf, u, x0 = cond_site)
epys_matrix <- cbind(epys_matrix, ep$y)
# Compute upper extremal range
uers[simulation] <- upperExtremalRange(rf, u, x0 = cond_site, finite = TRUE)
# Compute lower extremal range
lers[simulation] <- proportion_range(ep, proportion = 1)
# Compute excursion area and perimeter
areas[simulation] <- excursionArea(rf, u)
perims[simulation] <- excursionPerimeter(rf, u)
}
# Save simulation results
save(lers, uers, epys_matrix, var_matrix, perims, areas, file = statistics_path)
message("Simulations completed and saved to ", statistics_path)
}
# Load necessary libraries
if (!requireNamespace("ExcursionSets", quietly = TRUE)) {
message(paste("Looking in", getwd(), "for ExcursionSets_0.0.4.tar.gz."))
install.packages("ExcursionSets_0.0.4.tar.gz", repos = NULL, type = "source")
}
library(ExcursionSets)
if (!requireNamespace("ggplot2", quietly = TRUE)) {
install.packages("ggplot2")
}
library(ggplot2)
if (!requireNamespace("reshape2", quietly = TRUE)) {
install.packages("reshape2")
}
library(reshape2)
if (!requireNamespace("excursions", quietly = TRUE)) {
install.packages("excursions")
}
library(excursions)
# ------------------------------
# Configuration Parameters
# ------------------------------
HALF_WIDTH <- 0.5  # Set to 2 or 0.5 based on desired configuration
SIDE <- TRUE       # TRUE to choose point on boundary, FALSE otherwise
# Generate file name components based on parameters
fname1 <- if (HALF_WIDTH == 2) "2" else "05"
fname2 <- if (SIDE) "_side" else ""
x_val <- if (SIDE) HALF_WIDTH else 0
# Construct paths for generator and data files
generator_path <- paste0("gaussian_generator_matern_-", fname1, "to", fname1, fname2, ".RData")
statistics_path <- paste0("statistics_-", fname1, "to", fname1, "_u99", fname2, ".RData")
bootstraps_path <- paste0("bootstraps_-", fname1, "to", fname1, "_u99", fname2, ".RData")
# Define conditional site based on SIDE parameter
cond_site <- data.frame(x = x_val, y = 0)
# ------------------------------
# Random Field Generator Setup
# ------------------------------
if (file.exists(generator_path)) {
message("Loading generator: ", generator_path)
load(generator_path)  # Loads 'gen' object
} else {
# Define grid for random field
grid_seq <- seq(-HALF_WIDTH, HALF_WIDTH, length.out = 51)
grid <- expand.grid(x = grid_seq, y = grid_seq)
message("Building the random field generator: ", generator_path,
" from ", min(grid$x), " to ", max(grid$x),
" with ", length(grid_seq), " entries per side.")
# Initialize random field generator with Matern covariance
gen <- random.field.generator(
grid,
cov.model("Matern", nu = 2.5),
cond_sites = cond_site
)
message("Generator built. Saving to ", generator_path, "...")
save(gen, file = generator_path)
message("Generator saved.")
}
# ------------------------------
# Helper Function: Proportion Range
# ------------------------------
proportion_range <- function(ep, proportion = 1) {
# Binary search to find the smallest x such that ep$y[x] < proportion
left <- 1
right <- length(ep$y)
result <- NULL
while (left <= right) {
mid <- floor((left + right) / 2)
if (ep$y[mid] < proportion) {
result <- mid
right <- mid - 1  # Continue searching to the left
} else {
left <- mid + 1    # Continue searching to the right
}
}
if (is.null(result)) {
return(Inf)
}
return(ep$x[result])
}
# ------------------------------
# Simulation Parameters
# ------------------------------
p <- 0.99
u <- qnorm(p)
N <- 500  # Number of simulations
# Initialize storage for simulation results
var_matrix <- matrix(nrow = 0, ncol = N)
epys_matrix <- matrix(nrow = 0, ncol = N)
uers <- numeric(N)
lers <- numeric(N)
areas <- numeric(N)
perims <- numeric(N)
# ------------------------------
# Load or Perform Simulations
# ------------------------------
if (file.exists(statistics_path)) {
message("Loading simulation data: ", statistics_path)
load(statistics_path)  # Loads 'lers', 'uers', 'epys', 'var_matrix', 'perims', 'areas'
# Generate a random field for delta calculation
rf_sample <- generateGaussian(gen, u, exceedance = TRUE)
ep_sample <- extent.profile(rf_sample, u, x0 = cond_site)
} else {
message("Starting simulations...")
for (simulation in 1:N) {
if (simulation %% 50 == 0) {
message("Simulation ", simulation, " of ", N)
}
# Generate Gaussian random field exceeding threshold 'u'
rf <- generateGaussian(gen, u, exceedance = TRUE)
# Store field values
var_matrix <- cbind(var_matrix, rf$values)
# Compute extent profile
ep <- extent.profile(rf, u, x0 = cond_site)
epys_matrix <- cbind(epys_matrix, ep$y)
# Compute upper extremal range
uers[simulation] <- upperExtremalRange(rf, u, x0 = cond_site, finite = TRUE)
# Compute lower extremal range
lers[simulation] <- proportion_range(ep, proportion = 1)
# Compute excursion area and perimeter
areas[simulation] <- excursionArea(rf, u)
perims[simulation] <- excursionPerimeter(rf, u)
}
# Save simulation results
save(lers, uers, epys_matrix, var_matrix, perims, areas, file = statistics_path)
message("Simulations completed and saved to ", statistics_path)
}
# ------------------------------
# Bootstrapping Procedure
# ------------------------------
if (file.exists(bootstraps_path)) {
message("Loading bootstrap data: ", bootstraps_path)
load(bootstraps_path)  # Loads 'N_bootstraps', 'df', 'bottom'
} else {
message("Starting bootstrapping...")
# Extract delta from random field sample
delta <- rf_sample$deltas[1]
N_bootstraps <- 200
bootstrap_results <- data.frame(
theta_1 = numeric(N_bootstraps),
theta_2 = numeric(N_bootstraps),
theta_3 = numeric(N_bootstraps),
theta_4 = numeric(N_bootstraps),
theta_5 = numeric(N_bootstraps)
)
for (bs in 1:N_bootstraps) {
if (bs %% 20 == 0) {
message("Bootstrap ", bs, " of ", N_bootstraps)
}
# Sample indices with replacement
bs_indices <- sample(1:N, size = N, replace = TRUE)
# Compute bootstrap estimates
bootstrap_results$theta_1[bs] <- median(lers[bs_indices])
bootstrap_results$theta_2[bs] <- median(uers[bs_indices])
# Update extent profile and compute theta_3
ep_boot <- list(
x = ep_sample$x,
y = apply(epys_matrix[, bs_indices, drop = FALSE], 1, mean)
)
bootstrap_results$theta_3[bs] <- proportion_range(ep_boot, proportion = 0.5)
# Compute excursions and confidence set for theta_4
excursions_result <- excursions::excursions.mc(
var_matrix[, bs_indices],
u = u,
alpha = 0.5,
type = ">"
)
confidence_set <- random.field(excursions_result$F, gen$grid)
bootstrap_results$theta_4[bs] <- sqrt(excursionArea(confidence_set, 0.5))
# Compute theta_5
bootstrap_results$theta_5[bs] <- (8 / pi) * sum(areas[bs_indices]) / sum(perims[bs_indices])
}
# Assign column names
names(bootstrap_results) <- c("theta_1", "theta_2", "theta_3", "theta_4", "theta_5")
# Calculate log(delta) for plotting purposes
bottom <- log(delta)
# Save bootstrap results
save(N_bootstraps, bootstrap_results, bottom, file = bootstraps_path)
message("Bootstrapping completed and saved to ", bootstraps_path)
}
# ------------------------------
# Bootstrapping Procedure
# ------------------------------
if (file.exists(bootstraps_path)) {
message("Loading bootstrap data: ", bootstraps_path)
load(bootstraps_path)  # Loads 'N_bootstraps', 'df', 'bottom'
} else {
message("Starting bootstrapping...")
# Extract delta from random field sample
delta <- rf$deltas[1]
N_bootstraps <- 200
bootstrap_results <- data.frame(
theta_1 = numeric(N_bootstraps),
theta_2 = numeric(N_bootstraps),
theta_3 = numeric(N_bootstraps),
theta_4 = numeric(N_bootstraps),
theta_5 = numeric(N_bootstraps)
)
for (bs in 1:N_bootstraps) {
if (bs %% 20 == 0) {
message("Bootstrap ", bs, " of ", N_bootstraps)
}
# Sample indices with replacement
bs_indices <- sample(1:N, size = N, replace = TRUE)
# Compute bootstrap estimates
bootstrap_results$theta_1[bs] <- median(lers[bs_indices])
bootstrap_results$theta_2[bs] <- median(uers[bs_indices])
# Update extent profile and compute theta_3
ep_boot <- list(
x = ep$x,
y = apply(epys_matrix[, bs_indices, drop = FALSE], 1, mean)
)
bootstrap_results$theta_3[bs] <- proportion_range(ep_boot, proportion = 0.5)
# Compute excursions and confidence set for theta_4
excursions_result <- excursions::excursions.mc(
var_matrix[, bs_indices],
u = u,
alpha = 0.5,
type = ">"
)
confidence_set <- random.field(excursions_result$F, gen$grid)
bootstrap_results$theta_4[bs] <- sqrt(excursionArea(confidence_set, 0.5))
# Compute theta_5
bootstrap_results$theta_5[bs] <- (8 / pi) * sum(areas[bs_indices]) / sum(perims[bs_indices])
}
# Assign column names
names(bootstrap_results) <- c("theta_1", "theta_2", "theta_3", "theta_4", "theta_5")
# Calculate log(delta) for plotting purposes
bottom <- log(delta)
# Save bootstrap results
save(N_bootstraps, bootstrap_results, bottom, file = bootstraps_path)
message("Bootstrapping completed and saved to ", bootstraps_path)
}
getwd()
source("C:/Users/rcotsaki/Code/pony-helping-treat/local_statistics.R")
getwd()
source("C:/Users/rcotsaki/Code/pony-helping-treat/local_statistics.R")
